<HTML>
<HEAD>
	<TITLE>emCore/emView.h</TITLE>
	<LINK REL="stylesheet" TYPE="text/css" HREF="styles.css">
	<SCRIPT TYPE="text/javascript" SRC="script.js"></SCRIPT>
</HEAD>
<BODY>

<SCRIPT LANGUAGE="JavaScript">TopBar();</SCRIPT>
<PRE><TT><SPAN CLASS=d><SPAN CLASS=c>//------------------------------------------------------------------------------
// <A CLASS=m HREF="emCore_emView_h.html#emView">emView</A>.h
//
// Copyright (C) 2004-2012,2014,2016-2017,2021 Oliver Hamann.
//
// Homepage: http://eaglemode.sourceforge.net/
//
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License version 3 as published by the
// Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU General Public License version 3 for
// more details.
//
// You should have received a copy of the GNU General Public License version 3
// along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
//------------------------------------------------------------------------------

</SPAN><SPAN CLASS=p>#ifndef emView_h
#define emView_h

#ifndef emCursor_h
#include &lt;<A CLASS=f HREF="emCore_emCursor_h.html">emCore/emCursor.h</A>&gt;
#endif

#ifndef emInput_h
#include &lt;<A CLASS=f HREF="emCore_emInput_h.html">emCore/emInput.h</A>&gt;
#endif

#ifndef emPainter_h
#include &lt;<A CLASS=f HREF="emCore_emPainter_h.html">emCore/emPainter.h</A>&gt;
#endif

#ifndef emCoreConfig_h
#include &lt;<A CLASS=f HREF="emCore_emCoreConfig_h.html">emCore/emCoreConfig.h</A>&gt;
#endif

</SPAN><SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A>;
<SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>;
<SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emWindow_h.html#emWindow">emWindow</A>;
<SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emScreen_h.html#emScreen">emScreen</A>;
<SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emViewAnimator_h.html#emViewAnimator">emViewAnimator</A>;
<SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emViewAnimator_h.html#emMagneticViewAnimator">emMagneticViewAnimator</A>;
<SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emViewAnimator_h.html#emVisitingViewAnimator">emVisitingViewAnimator</A>;
<SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emViewInputFilter_h.html#emViewInputFilter">emViewInputFilter</A>;
<SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emViewInputFilter_h.html#emCheatVIF">emCheatVIF</A>;


<A NAME="emView"></A><SPAN CLASS=c>//==============================================================================
//=================================== <A CLASS=m HREF="emCore_emView_h.html#emView">emView</A> ===================================
//==============================================================================

</SPAN><SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> : <SPAN CLASS=t>public </SPAN><A CLASS=l HREF="emCore_emContext_h.html#emContext">emContext</A> <SPAN CLASS=b>{

</SPAN><SPAN CLASS=t>public</SPAN>:

        <SPAN CLASS=c>// An <A CLASS=m HREF="emCore_emView_h.html#emView">emView</A> is a rectangle on the screen in which the user can see a
        // tree of panels (see class <A CLASS=m HREF="emCore_emPanel_h.html#emPanel">emPanel</A>). If not disabled by a feature
        // flag, the user can navigate through the panels by zooming, scrolling
        // and moving the focus.
        //
        // After constructing an <A CLASS=m HREF="emCore_emView_h.html#emView">emView</A>, an appropriate <A CLASS=m HREF="emCore_emView_h.html#emViewPort">emViewPort</A> should be
        // created on it. Otherwise the view is not connected to any screen or
        // input device (it uses an internal dummy <A CLASS=m HREF="emCore_emView_h.html#emViewPort">emViewPort</A> then). See the
        // derived class <A CLASS=m HREF="emCore_emWindow_h.html#emWindow">emWindow</A> - it solves the problem of connecting the
        // view. Another solution is the class <A CLASS=m HREF="emCore_emSubViewPanel_h.html#emSubViewPanel">emSubViewPanel</A>.
        //
        // Even, <A CLASS=m HREF="emCore_emView_h.html#emView">emView</A> does not create any panels. This should also be done by
        // the caller.
        //
        // <A CLASS=m HREF="emCore_emView_h.html#emView">emView</A> has been derived from <A CLASS=m HREF="emCore_emContext_h.html#emContext">emContext</A> so that it is easy to define
        // custom view settings as models of that context.

        </SPAN><SPAN CLASS=t>typedef int </SPAN>ViewFlags;
                <SPAN CLASS=c>// Data type for the feature flags of a view. Possible flags
                // are:
        </SPAN><SPAN CLASS=t>enum </SPAN><SPAN CLASS=b>{
                </SPAN>VF_POPUP_ZOOM         =(<SPAN CLASS=u>1</SPAN>&lt;&lt;<SPAN CLASS=u>0</SPAN>),
                        <SPAN CLASS=c>// The view pops up whenever the view is zoomed. For
                        // this feature to work, an <A CLASS=m HREF="emCore_emScreen_h.html#emScreen">emScreen</A> must be in the path
                        // of contexts, so that the view is able to create a
                        // private <A CLASS=m HREF="emCore_emWindow_h.html#emWindow">emWindow</A> as the popup.
                </SPAN>VF_ROOT_SAME_TALLNESS =(<SPAN CLASS=u>1</SPAN>&lt;&lt;<SPAN CLASS=u>1</SPAN>),
                        <SPAN CLASS=c>// The root panel always has the same tallness as the
                        // view. This is highly recommended when using
                        // VF_POPUP_ZOOM.
                </SPAN>VF_NO_ZOOM            =(<SPAN CLASS=u>1</SPAN>&lt;&lt;<SPAN CLASS=u>2</SPAN>),
                        <SPAN CLASS=c>// The view is always zoomed out. This implies having
                        // VF_NO_USER_NAVIGATION and not having VF_POPUP_ZOOM
                        // and not having VF_EGO_MODE.
                </SPAN>VF_NO_USER_NAVIGATION =(<SPAN CLASS=u>1</SPAN>&lt;&lt;<SPAN CLASS=u>3</SPAN>),
                        <SPAN CLASS=c>// The user cannot navigate in the view.
                </SPAN>VF_NO_FOCUS_HIGHLIGHT =(<SPAN CLASS=u>1</SPAN>&lt;&lt;<SPAN CLASS=u>4</SPAN>),
                        <SPAN CLASS=c>// The view does not show any focus highlight.
                </SPAN>VF_NO_ACTIVE_HIGHLIGHT=(<SPAN CLASS=u>1</SPAN>&lt;&lt;<SPAN CLASS=u>5</SPAN>),
                        <SPAN CLASS=c>// The view does not show any active highlight.
                </SPAN>VF_EGO_MODE           =(<SPAN CLASS=u>1</SPAN>&lt;&lt;<SPAN CLASS=u>6</SPAN>),
                        <SPAN CLASS=c>// This is a special mode of user interaction. The mouse
                        // pointer is degenerated to a cross-hair in the center
                        // of the view, and each mouse movement scrolls the
                        // view. This mode should not be used when there are
                        // multiple windows or views on the screen, because the
                        // mouse pointer cannot be moved. The name "ego mode"
                        // has been chosen because it is somehow similar to the
                        // mouse control in ego shooter games.
                </SPAN>VF_STRESS_TEST        =(<SPAN CLASS=u>1</SPAN>&lt;&lt;<SPAN CLASS=u>7</SPAN>)
                        <SPAN CLASS=c>// This repaints the view on every time slice and shows
                        // the frame rate in the upper-left corner. This feature
                        // exists for use by developers.
        </SPAN><SPAN CLASS=b>}</SPAN>;

        <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>(<A CLASS=l HREF="emCore_emContext_h.html#emContext">emContext</A> &amp; parentContext, ViewFlags viewFlags=<SPAN CLASS=u>0</SPAN>);
                <SPAN CLASS=c>// Constructor.
                // Arguments:
                //   parentContext - Parent context for this new context.
                //   viewFlags     - Initial feature flags.

        </SPAN><SPAN CLASS=t>virtual </SPAN>~<A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>();
                <SPAN CLASS=c>// Destructor. If a real view port has been created for this
                // view, it must be deleted before destructing the view. In
                // addition, it is always a good idea to delete the root panel
                // by destructors of derived classes, just because a panel could
                // depend on the properties of the derivative. For example,
                // <A CLASS=m HREF="emCore_emPanel_h.html#emPanel">emPanel</A>::GetWindow() must not be used after destructing the
                // <A CLASS=m HREF="emCore_emWindow_h.html#emWindow">emWindow</A>, and therefore the destructor of <A CLASS=m HREF="emCore_emWindow_h.html#emWindow">emWindow</A> deletes
                // the panels itself.

        </SPAN><SPAN CLASS=t>void </SPAN>LinkCrossPtr(emCrossPtrPrivate &amp; crossPtr);
                <SPAN CLASS=c>// This means <A CLASS=m HREF="emCore_emCrossPtr_h.html#emCrossPtr">emCrossPtr</A>&lt;<A CLASS=m HREF="emCore_emView_h.html#emView">emView</A>&gt; is possible.

        </SPAN>ViewFlags GetViewFlags() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>void </SPAN>SetViewFlags(ViewFlags viewFlags);
                <SPAN CLASS=c>// Get or set the features of this view.

        </SPAN><SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; GetViewFlagsSignal() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// This signal is signaled when the features of this view have
                // changed.

        </SPAN><A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> GetBackgroundColor() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>void </SPAN>SetBackgroundColor(<A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> c);
                <SPAN CLASS=c>// Get or set the background color of this view. This color is
                // used for areas which are not covered by the panels, or where
                // the panels are transparent. The default is some grey.

        </SPAN><SPAN CLASS=t>virtual </SPAN><A CLASS=l HREF="emCore_emString_h.html#emString">emString</A> GetTitle() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the title to be shown for this view. The default
                // implementation returns the title of the active panel (not
                // directly, but updated through an engine). See also:
                // InvalidateTitle()

        </SPAN><SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; GetTitleSignal() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// This signal is signaled when the title has changed.

        </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * CreateControlPanel(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> &amp; parent, <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emString_h.html#emString">emString</A> &amp; name);
                <SPAN CLASS=c>// If this is a content view, this method may be called to
                // create a control panel in a control view. The call is
                // forwarded to the active panel. The result can be NULL which
                // means to have no control panel. The caller should delete the
                // control panel before calling CreateControlPanel again, and
                // before destructing this view.

        </SPAN><SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; GetControlPanelSignal() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// This signal is signaled when the control panel should be
                // recreated.

        </SPAN><SPAN CLASS=t>bool </SPAN>IsFocused() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Whether this view has the focus.

        </SPAN><SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; GetFocusSignal() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// This signal is signaled when the focus of this view has
                // changed.

        </SPAN><SPAN CLASS=t>void </SPAN>Focus();
                <SPAN CLASS=c>// Make that this view has the focus, if possible by the
                // <A CLASS=m HREF="emCore_emView_h.html#emViewPort">emViewPort</A> implementation. Hint: If this is an <A CLASS=m HREF="emCore_emWindow_h.html#emWindow">emWindow</A>, you
                // may want to call Raise() before.

        </SPAN><A CLASS=l HREF="emCore_emWindow_h.html#emWindow">emWindow</A> * GetWindow() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the window of this view. It returns the nearest window
                // within the path of contexts to this view. If this view itself
                // is a window, that window is returned. If no window can be
                // found, NULL is returned. The result is cached internally.

        </SPAN><A CLASS=l HREF="emCore_emScreen_h.html#emScreen">emScreen</A> * GetScreen() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the screen of this view. If GetWindow() returns non-NULL,
                // the screen of that window is returned. Otherwise the call is
                // forwarded to <A CLASS=m HREF="emCore_emScreen_h.html#emScreen">emScreen</A>::LookupInherited(*this). The result is
                // cached internally.

        </SPAN><SPAN CLASS=t>double </SPAN>GetHomeX() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetHomeY() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetHomeWidth() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetHomeHeight() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetHomePixelTallness() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetHomeTallness() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the home geometry of this view on the screen. "Home"
                // means the state where the view is not popped up by the
                // popup-zoom feature. X, Y, Width and Height are the
                // coordinates of the view rectangle, measured in pixels on the
                // screen. PixelTallness is the height/width ratio of the pixels
                // on the monitor (as far as known by the implementation of
                // <A CLASS=m HREF="emCore_emView_h.html#emViewPort">emViewPort</A>). And Tallness is the height/width ration of the
                // view on the monitor. It is equal to
                // Height/Width*PixelTallness.

        </SPAN><SPAN CLASS=t>double </SPAN>GetCurrentX() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetCurrentY() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetCurrentWidth() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetCurrentHeight() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetCurrentPixelTallness() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetCurrentTallness() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the current geometry of this view on the screen. This is
                // like GetHomeX(), GetHomeY() and so on, but if the view is
                // currently popped up by the popup-zoom feature, the geometry
                // of the popup is returned (should not make any difference for
                // PixelTallness).

        </SPAN><SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; GetGeometrySignal() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// This signal is signaled when the home geometry or the current
                // geometry of this view has changed.

        </SPAN><SPAN CLASS=t>void </SPAN>GetMaxPopupViewRect(<SPAN CLASS=t>double </SPAN>* pX, <SPAN CLASS=t>double </SPAN>* pY,
                                 <SPAN CLASS=t>double </SPAN>* pW, <SPAN CLASS=t>double </SPAN>* pH) <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the pixel coordinates of the maximum visible rectangle of
                // a popup. This is the bounding rectangle of all display
                // monitors, which intersect the home rectangle of the view. The
                // given pointers are for returning the rectangle coordinates
                // (x,y,w,h). NULL pointers are allowed.

        </SPAN><A CLASS=l HREF="emCore_emViewInputFilter_h.html#emViewInputFilter">emViewInputFilter</A> * GetFirstVIF() <SPAN CLASS=t>const</SPAN>;
        <A CLASS=l HREF="emCore_emViewInputFilter_h.html#emViewInputFilter">emViewInputFilter</A> * GetLastVIF() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the first or last view input filter (VIF) in the chain of
                // the VIFs of this view. The default chain (after constructing
                // the view) contains <A CLASS=m HREF="emCore_emViewInputFilter_h.html#emDefaultTouchVIF">emDefaultTouchVIF</A>, <A CLASS=m HREF="emCore_emViewInputFilter_h.html#emCheatVIF">emCheatVIF</A>,
                // <A CLASS=m HREF="emCore_emViewInputFilter_h.html#emKeyboardZoomScrollVIF">emKeyboardZoomScrollVIF</A>, and <A CLASS=m HREF="emCore_emViewInputFilter_h.html#emMouseZoomScrollVIF">emMouseZoomScrollVIF</A> in that
                // order. This could change in future versions. You can modify
                // the chain simply by deleting and creating VIFs as you like.
                // See <A CLASS=m HREF="emCore_emViewInputFilter_h.html#emViewInputFilter">emViewInputFilter</A> for more details. Note that the
                // zoom/scroll VIFs have no effect when VF_NO_USER_NAVIGATION is
                // set in the view flags. Also, never forget about the
                // possibility of parent and child views (=&gt;<A CLASS=m HREF="emCore_emSubViewPanel_h.html#emSubViewPanel">emSubViewPanel</A>).
                // Parent views should always have VF_NO_ZOOM.

        </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * GetRootPanel() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the root panel of this view. Returns NULL when this view
                // has no panels.

        </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * GetSupremeViewedPanel() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the supreme viewed panel. It is the upper-most panel in
                // the panel tree which has IsViewed()==true. Returns NULL when
                // this view has no panels. The supreme viewed panel is always
                // chosen automatically by the view, depending on the visit
                // state.

        </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * GetActivePanel() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the active panel. The active panel is the panel which is
                // focused when the view is focused. Returns NULL when this view
                // has no panels.

        </SPAN><SPAN CLASS=t>bool </SPAN>IsActivationAdherent() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Whether the panel activation is adherent. It usually means
                // that the activation has been made by the user.

        </SPAN><SPAN CLASS=t>void </SPAN>SetActivePanel(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>bool </SPAN>adherent=<SPAN CLASS=k>true</SPAN>);
                <SPAN CLASS=c>// Make the given Panel the active panel, or if it is not
                // focusable, make the nearest focusable ancestor active.
                // The location of the view is not changed.

        </SPAN><SPAN CLASS=t>void </SPAN>SetActivePanelBestPossible();
                <SPAN CLASS=c>// Search for a viewed panel whose position in the view is best
                // for being the active panel, and activate it. But if the old
                // activation is adherent, the activation is changed only if it
                // is really too bad.

        </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * GetPanelByIdentity(<SPAN CLASS=t>const char </SPAN>* identity) <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Search for a panel by identity (see <A CLASS=m HREF="emCore_emPanel_h.html#emPanel">emPanel</A>::GetIdentity()).
                // Returns NULL if not found.

        </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * GetPanelAt(<SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y) <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the uppermost panel at the given point.

        </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * GetFocusablePanelAt(<SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y,
                                      <SPAN CLASS=t>bool </SPAN>checkSubstance) <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the uppermost focusable panel at the given point. If
                // checkSubstance is true, the substance rectangles of the
                // panels are checked. Otherwise the whole panel rectangles are
                // checked.

        </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * GetVisitedPanel(<SPAN CLASS=t>double </SPAN>* pRelX=<SPAN CLASS=u>NULL</SPAN>, <SPAN CLASS=t>double </SPAN>* pRelY=<SPAN CLASS=u>NULL</SPAN>,
                                  <SPAN CLASS=t>double </SPAN>* pRelA=<SPAN CLASS=u>NULL</SPAN>) <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the visited panel and optionally relative coordinates.
                // The visited panel is the one on which the view is currently
                // anchored. That means, if any panel layout is changed, the
                // visited panel keeps its position and size in the view.
                // Normally, the visited panel is the active panel. But if the
                // active panel is not viewed, the visited panel is the viewed
                // panel which is (in the tree of panels) nearest to the active
                // panel.
                // Arguments:
                //   pRelX, pRelY - Pointers for returning the distance vector
                //                  between the center of the view and the
                //                  center of the panel, measured in view widths
                //                  and heights.
                //   pRelA        - Pointer for returning the area size of the
                //                  view relative to the area size of the panel.
                // Returns:
                //   The visited panel, or NULL if this view has no panels.

        </SPAN><SPAN CLASS=t>void </SPAN>Visit(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>double </SPAN>relX, <SPAN CLASS=t>double </SPAN>relY, <SPAN CLASS=t>double </SPAN>relA,
                   <SPAN CLASS=t>bool </SPAN>adherent);
        <SPAN CLASS=t>void </SPAN>Visit(<SPAN CLASS=t>const char </SPAN>* identity, <SPAN CLASS=t>double </SPAN>relX, <SPAN CLASS=t>double </SPAN>relY, <SPAN CLASS=t>double </SPAN>relA,
                   <SPAN CLASS=t>bool </SPAN>adherent, <SPAN CLASS=t>const char </SPAN>* subject=<SPAN CLASS=u>NULL</SPAN>);
                <SPAN CLASS=c>// Start to visit a panel. This means to position the view
                // relative to the given panel and make that panel the active
                // panel. The operation is animated and may take a long time.
                // Arguments:
                //   panel     - The panel to be visited.
                //   identity  - Identity of the panel to be visited.
                //   relX,relY - Desired distance vector between the center of
                //               the view and the center of the panel, measured
                //               in view widths and heights.
                //   relA      - Desired area size of the view relative to the
                //               area size of the panel.
                //   adherent  - Whether the activation shall be adherent.
                //   subject   - A subject text to be shown in an info box
                //               for the case the operation takes much time.
                //               Best is to give the title of the panel.

        </SPAN><SPAN CLASS=t>void </SPAN>Visit(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>bool </SPAN>adherent);
        <SPAN CLASS=t>void </SPAN>Visit(<SPAN CLASS=t>const char </SPAN>* identity, <SPAN CLASS=t>bool </SPAN>adherent,
                   <SPAN CLASS=t>const char </SPAN>* subject=<SPAN CLASS=u>NULL</SPAN>);
                <SPAN CLASS=c>// Like the Visit methods above, but automatically
                // choose a good position for the panel in the view.

        </SPAN><SPAN CLASS=t>void </SPAN>VisitFullsized(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>bool </SPAN>adherent,
                            <SPAN CLASS=t>bool </SPAN>utilizeView=<SPAN CLASS=k>false</SPAN>);
        <SPAN CLASS=t>void </SPAN>VisitFullsized(<SPAN CLASS=t>const char </SPAN>* identity, <SPAN CLASS=t>bool </SPAN>adherent,
                            <SPAN CLASS=t>bool </SPAN>utilizeView=<SPAN CLASS=k>false</SPAN>, <SPAN CLASS=t>const char </SPAN>* subject=<SPAN CLASS=u>NULL</SPAN>);
                <SPAN CLASS=c>// Like the Visit methods above, but position the view so that
                // the panel is shown full-sized.

        </SPAN><SPAN CLASS=t>void </SPAN>RawVisit(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>double </SPAN>relX, <SPAN CLASS=t>double </SPAN>relY, <SPAN CLASS=t>double </SPAN>relA);
        <SPAN CLASS=t>void </SPAN>RawVisit(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel);
        <SPAN CLASS=t>void </SPAN>RawVisitFullsized(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>bool </SPAN>utilizeView=<SPAN CLASS=k>false</SPAN>);
                <SPAN CLASS=c>// Like the Visit methods above, but without animation (these
                // methods act immediately), without aborting any active
                // animation, and without changing the active panel.

        </SPAN><SPAN CLASS=t>void </SPAN>VisitNext();
        <SPAN CLASS=t>void </SPAN>VisitPrev();
        <SPAN CLASS=t>void </SPAN>VisitFirst();
        <SPAN CLASS=t>void </SPAN>VisitLast();
        <SPAN CLASS=t>void </SPAN>VisitLeft();
        <SPAN CLASS=t>void </SPAN>VisitRight();
        <SPAN CLASS=t>void </SPAN>VisitUp();
        <SPAN CLASS=t>void </SPAN>VisitDown();
        <SPAN CLASS=t>void </SPAN>VisitNeighbour(<SPAN CLASS=t>int </SPAN>direction);
        <SPAN CLASS=t>void </SPAN>VisitIn();
        <SPAN CLASS=t>void </SPAN>VisitOut();
                <SPAN CLASS=c>// Start to visit a sister, parent or child of the active panel.
                // This walks the tree of focusable panels only.
                // VisitNeighbour(0) is like VisitRight(), 1 like Down, 2 like
                // Left and 3 like Up.

        </SPAN><SPAN CLASS=t>void </SPAN>Scroll(<SPAN CLASS=t>double </SPAN>deltaX, <SPAN CLASS=t>double </SPAN>deltaY);
                <SPAN CLASS=c>// Scroll the view. This aborts any active animation and
                // performs immediately without animation. The active panel is
                // adapted.
                // Arguments:
                //   deltaX     - How many pixels to scroll in X direction.
                //                A positive value means to scroll right.
                //   deltaY     - How many pixels to scroll in Y direction.
                //                A positive value means to scroll down.

        </SPAN><SPAN CLASS=t>void </SPAN>Zoom(<SPAN CLASS=t>double </SPAN>fixX, <SPAN CLASS=t>double </SPAN>fixY, <SPAN CLASS=t>double </SPAN>factor);
                <SPAN CLASS=c>// Zoom the view. This aborts any active animation and performs
                // immediately without animation. The active panel is adapted.
                // Arguments:
                //   fixX, fixY - Fix point for the zooming.
                //   factor     - Zoom factor. A value less than 1.0 means to
                //                zoom out, and a value greater than 1.0 means
                //                to zoom in.

        </SPAN><SPAN CLASS=t>void </SPAN>RawScrollAndZoom(
                <SPAN CLASS=t>double </SPAN>fixX, <SPAN CLASS=t>double </SPAN>fixY,
                <SPAN CLASS=t>double </SPAN>deltaX, <SPAN CLASS=t>double </SPAN>deltaY, <SPAN CLASS=t>double </SPAN>deltaZ,
                <A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel=<SPAN CLASS=u>NULL</SPAN>, <SPAN CLASS=t>double </SPAN>* pDeltaXDone=<SPAN CLASS=u>NULL</SPAN>,
                <SPAN CLASS=t>double </SPAN>* pDeltaYDone=<SPAN CLASS=u>NULL</SPAN>, <SPAN CLASS=t>double </SPAN>* pDeltaZDone=<SPAN CLASS=u>NULL
        </SPAN>);
                <SPAN CLASS=c>// Scroll and zoom the view without aborting animations and
                // without changing the active panel. The scrolling is performed
                // before the zooming.
                // Arguments:
                //   fixX, fixY  - Fix point for the zooming.
                //   deltaX      - How many pixels to scroll in X direction.
                //                 A positive value means to scroll right.
                //   deltaY      - How many pixels to scroll in Y direction.
                //                 A positive value means to scroll down.
                //   deltaZ      - How many pixels to zoom. The zoom factor is:
                //                 exp(deltaZ * GetZoomFactorLogarithmPerPixel())
                //   panel       - A panel to be used for the calculations.
                //                 It should be a panel which is also viewed
                //                 after the operation. If NULL or not viewed,
                //                 the visited panel is used.
                //   pDeltaXDone - Pointer for returning the number of pixels by
                //                 which the view actually has been scrolled in
                //                 X.
                //   pDeltaYDone - Pointer for returning the number of pixels by
                //                 which the view actually has been scrolled in
                //                 Y.
                //   pDeltaZDone - Pointer for returning the number of pixels by
                //                 which the view actually has been zoomed.

        </SPAN><SPAN CLASS=t>double </SPAN>GetZoomFactorLogarithmPerPixel() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// How much zooming feels the same amount of motion to the user
                // as scrolling one pixel, returned as natural logarithm of zoom
                // factor.

        </SPAN><SPAN CLASS=t>void </SPAN>ZoomOut();
                <SPAN CLASS=c>// Zoom out the view completely. This aborts any active
                // animation and performs immediately without animation. The
                // active panel is adapted.

        </SPAN><SPAN CLASS=t>void </SPAN>RawZoomOut();
                <SPAN CLASS=c>// Like ZoomOut(), but without aborting animations and without
                // changing the active panel.

        </SPAN><SPAN CLASS=t>bool </SPAN>IsZoomedOut() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Whether the view is currently zoomed out completely.

        </SPAN><SPAN CLASS=t>bool </SPAN>IsPoppedUp() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Whether the view is in popped up state.

        </SPAN><SPAN CLASS=t>void </SPAN>SignalEOIDelayed();
                <SPAN CLASS=c>// After calling this, the End-Of-Interaction signal will be
                // signaled, but with a delay of some time slices.

        </SPAN><SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; GetEOISignal() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the End-Of-Interaction signal. This signal indicates an
                // end of a temporary user interaction. It has been invented for
                // <A CLASS=m HREF="emCore_emButton_h.html#emButton">emButton</A> (see <A CLASS=m HREF="emCore_emButton_h.html#emButton">emButton</A>::IsNoEOI()). If the view has
                // VF_POPUP_ZOOM set, the application should call ZoomOut() when
                // an EOI has been signaled.

        </SPAN><SPAN CLASS=t>bool </SPAN>IsSoftKeyboardShown() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>void </SPAN>ShowSoftKeyboard(<SPAN CLASS=t>bool </SPAN>show);
                <SPAN CLASS=c>// Get and set whether to show a software keyboard (if there is
                // no hardware keyboard).

        </SPAN>emUInt64 GetInputClockMS() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the time of the currently handled input event and input
                // state, or the current time if all events are handled. The
                // time is measured in milliseconds and starts anywhere, but it
                // should never overflow.

        </SPAN><SPAN CLASS=t>virtual double </SPAN>GetTouchEventPriority(
                <SPAN CLASS=t>double </SPAN>touchX, <SPAN CLASS=t>double </SPAN>touchY, <SPAN CLASS=t>bool </SPAN>afterVIFs=<SPAN CLASS=k>false
        </SPAN>) <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the touch event priority of this view for a certain touch
                // position. (See <A CLASS=m HREF="emCore_emPanel_h.html#emPanel">emPanel</A>::GetTouchEventPriority).
                // Arguments:
                //   touchX, touchY - Position of a first touch in view
                //                    coordinates.
                //   afterVIFs      - Whether to leave out the view input filters
                //                    in the calculation.

        </SPAN><A CLASS=l HREF="emCore_emViewAnimator_h.html#emViewAnimator">emViewAnimator</A> * GetActiveAnimator() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the active view animator, or NULL if none is active.

        </SPAN><SPAN CLASS=t>void </SPAN>ActivateMagneticViewAnimator();
                <SPAN CLASS=c>// Activate the magnetic view animator.

        </SPAN><SPAN CLASS=t>void </SPAN>AbortActiveAnimator();
                <SPAN CLASS=c>// Abort any activate view animator.

</SPAN><SPAN CLASS=t>protected</SPAN>:

        <SPAN CLASS=t>virtual void </SPAN>Input(<A CLASS=l HREF="emCore_emInput_h.html#emInputEvent">emInputEvent</A> &amp; event, <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emInput_h.html#emInputState">emInputState</A> &amp; state);
                <SPAN CLASS=c>// Process input form keyboard, mouse, and touch after filtering
                // it by the view input filters. The default implementation
                // forwards to the panels.
                // Arguments:
                //   event  - An input event. It may be eaten by calling
                //            event.Eat(). The event reference in non-const only
                //            for that.
                //   state  - The current input state.

        </SPAN><SPAN CLASS=t>virtual </SPAN><A CLASS=l HREF="emCore_emCursor_h.html#emCursor">emCursor</A> GetCursor() <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Get the mouse cursor to be shown for this view. The default
                // implementation returns the cursor of the panel where the
                // mouse is. See also: InvalidateCursor()

        </SPAN><SPAN CLASS=t>virtual void </SPAN>Paint(
                <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPainter_h.html#emPainter">emPainter</A> &amp; painter, <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> canvasColor
        ) <SPAN CLASS=t>const</SPAN>;
                <SPAN CLASS=c>// Paint this view. The default implementation paints the
                // panels, the focus and an info box when seeking.
                // Arguments:
                //   painter     - A painter for painting the view to the
                //                 screen. Origin and scaling of this painter
                //                 are prepared for having the coordinate system
                //                 of the screen.
                //   canvasColor - Color of the canvas.
                // See also: InvalidatePainting()

        </SPAN><SPAN CLASS=t>virtual void </SPAN>InvalidateTitle();
                <SPAN CLASS=c>// Indicate a change in the results of GetTitle(). The default
                // implementation simply signals the title signal (see
                // GetTitleSignal()).

        </SPAN><SPAN CLASS=t>void </SPAN>InvalidateCursor();
                <SPAN CLASS=c>// Indicate a change in the results of GetCursor(). After
                // calling this, showings of the cursor will be updated.

        </SPAN><SPAN CLASS=t>void </SPAN>InvalidatePainting();
        <SPAN CLASS=t>void </SPAN>InvalidatePainting(<SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y, <SPAN CLASS=t>double </SPAN>w, <SPAN CLASS=t>double </SPAN>h);
                <SPAN CLASS=c>// Indicate a change in the results of Paint(). After calling
                // this, the view will be re-painted. The second version of the
                // method allows to invalidate just a rectangular area instead
                // of the whole view.
                // Arguments:
                //   x,y,w,h - Upper-left corner and size of the rectangle.

        </SPAN><SPAN CLASS=t>virtual void </SPAN>DoCustomCheat(<SPAN CLASS=t>const char </SPAN>* func);
                <SPAN CLASS=c>// This method could be overloaded for implementing custom cheat
                // codes. For example, if the user enters "chEat:abc!", this
                // method is called with func="abc". The default implementation
                // calls the ancestor view, if there. For the cheat codes
                // implemented by default, see the implementation of
                // <A CLASS=m HREF="emCore_emViewInputFilter_h.html#emCheatVIF">emCheatVIF</A>::Input.

        // - - - - - - - - - - Depreciated methods - - - - - - - - - - - - - - -
        // The following virtual non-const methods have been replaced by const
        // methods (see above). The old versions still exist here with the
        // "final" keyword added, so that old overridings will fail to compile.
        // If you run into this, please adapt your overridings by adding "const".
</SPAN><SPAN CLASS=t>public</SPAN>:
        <SPAN CLASS=t>virtual </SPAN><A CLASS=l HREF="emCore_emString_h.html#emString">emString</A> GetTitle() final;
        <SPAN CLASS=t>virtual double </SPAN>GetTouchEventPriority(
                <SPAN CLASS=t>double </SPAN>touchX, <SPAN CLASS=t>double </SPAN>touchY, <SPAN CLASS=t>bool </SPAN>afterVIFs=<SPAN CLASS=k>false
        </SPAN>) final;
<SPAN CLASS=t>protected</SPAN>:
        <SPAN CLASS=t>virtual </SPAN><A CLASS=l HREF="emCore_emCursor_h.html#emCursor">emCursor</A> GetCursor() final;
        <SPAN CLASS=t>virtual void </SPAN>Paint(<SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPainter_h.html#emPainter">emPainter</A> &amp; painter, <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> canvasColor) final;
        <SPAN CLASS=c>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

</SPAN><SPAN CLASS=t>private</SPAN>:
        <SPAN CLASS=t>friend class </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>;
        <SPAN CLASS=t>friend class </SPAN><A CLASS=l HREF="emCore_emViewAnimator_h.html#emViewAnimator">emViewAnimator</A>;
        <SPAN CLASS=t>friend class </SPAN><A CLASS=l HREF="emCore_emViewAnimator_h.html#emVisitingViewAnimator">emVisitingViewAnimator</A>;
        <SPAN CLASS=t>friend class </SPAN><A CLASS=l HREF="emCore_emViewInputFilter_h.html#emViewInputFilter">emViewInputFilter</A>;
        <SPAN CLASS=t>friend class </SPAN><A CLASS=l HREF="emCore_emViewInputFilter_h.html#emCheatVIF">emCheatVIF</A>;
        <SPAN CLASS=t>friend class </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A>;
        <SPAN CLASS=t>friend class </SPAN><A CLASS=l HREF="emCore_emSubViewPanel_h.html#emSubViewPanel">emSubViewPanel</A>;
        <SPAN CLASS=t>friend class </SPAN><A CLASS=l HREF="emCore_emWindow_h.html#emWindow">emWindow</A>;

        <SPAN CLASS=t>struct </SPAN>PanelRingNode <SPAN CLASS=b>{
                </SPAN>PanelRingNode * Prev;
                PanelRingNode * Next;
        <SPAN CLASS=b>}</SPAN>;

        <SPAN CLASS=t>void </SPAN>SetWindowAndScreen(<A CLASS=l HREF="emCore_emWindow_h.html#emWindow">emWindow</A> * window=<SPAN CLASS=u>NULL</SPAN>);

        <SPAN CLASS=t>void </SPAN>SetFocused(<SPAN CLASS=t>bool </SPAN>focused);
        <SPAN CLASS=t>void </SPAN>SetGeometry(<SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y, <SPAN CLASS=t>double </SPAN>width, <SPAN CLASS=t>double </SPAN>height,
                         <SPAN CLASS=t>double </SPAN>pixelTallness);

        <SPAN CLASS=t>void </SPAN>AddToNoticeList(PanelRingNode * node);

        <SPAN CLASS=t>void </SPAN>Update();

        <SPAN CLASS=t>void </SPAN>CalcVisitCoords(<SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>double </SPAN>* pRelX,
                             <SPAN CLASS=t>double </SPAN>* pRelY, <SPAN CLASS=t>double </SPAN>* pRelA) <SPAN CLASS=t>const</SPAN>;

        <SPAN CLASS=t>void </SPAN>CalcVisitFullsizedCoords(<SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>double </SPAN>* pRelX,
                                      <SPAN CLASS=t>double </SPAN>* pRelY, <SPAN CLASS=t>double </SPAN>* pRelA,
                                      <SPAN CLASS=t>bool </SPAN>utilizeView=<SPAN CLASS=k>false</SPAN>) <SPAN CLASS=t>const</SPAN>;

        <SPAN CLASS=t>void </SPAN>RawVisit(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>double </SPAN>relX, <SPAN CLASS=t>double </SPAN>relY, <SPAN CLASS=t>double </SPAN>relA,
                      <SPAN CLASS=t>bool </SPAN>forceViewingUpdate);
        <SPAN CLASS=t>void </SPAN>RawVisitAbs(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>double </SPAN>vx, <SPAN CLASS=t>double </SPAN>vy, <SPAN CLASS=t>double </SPAN>vw,
                         <SPAN CLASS=t>bool </SPAN>forceViewingUpdate);
        <SPAN CLASS=t>void </SPAN>RawZoomOut(<SPAN CLASS=t>bool </SPAN>forceViewingUpdate);

        <SPAN CLASS=t>void </SPAN>FindBestSVP(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * * pPanel, <SPAN CLASS=t>double </SPAN>* pVx, <SPAN CLASS=t>double </SPAN>* pVy,
                         <SPAN CLASS=t>double </SPAN>* pVw) <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>bool </SPAN>FindBestSVPInTree(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * * pPanel, <SPAN CLASS=t>double </SPAN>* pVx, <SPAN CLASS=t>double </SPAN>* pVy,
                               <SPAN CLASS=t>double </SPAN>* pVw, <SPAN CLASS=t>bool </SPAN>covering) <SPAN CLASS=t>const</SPAN>;

        <SPAN CLASS=t>void </SPAN>SwapViewPorts(<SPAN CLASS=t>bool </SPAN>swapFocus);

        <SPAN CLASS=t>void </SPAN>RecurseInput(<A CLASS=l HREF="emCore_emInput_h.html#emInputEvent">emInputEvent</A> &amp; event,
                          <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emInput_h.html#emInputState">emInputState</A> &amp; state);
        <SPAN CLASS=t>void </SPAN>RecurseInput(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <A CLASS=l HREF="emCore_emInput_h.html#emInputEvent">emInputEvent</A> &amp; event,
                          <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emInput_h.html#emInputState">emInputState</A> &amp; state);

        <SPAN CLASS=t>void </SPAN>InvalidateHighlight();
        <SPAN CLASS=t>void </SPAN>PaintHighlight(<SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPainter_h.html#emPainter">emPainter</A> &amp; painter) <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>static void </SPAN>PaintHighlightArrowsOnLine(
                <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPainter_h.html#emPainter">emPainter</A> &amp; painter, <SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y,
                <SPAN CLASS=t>double </SPAN>dx, <SPAN CLASS=t>double </SPAN>dy, <SPAN CLASS=t>double </SPAN>pos, <SPAN CLASS=t>double </SPAN>delta,
                <SPAN CLASS=t>int </SPAN>count, <SPAN CLASS=t>double </SPAN>goalX, <SPAN CLASS=t>double </SPAN>goalY, <SPAN CLASS=t>double </SPAN>arrowSize,
                <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> shadowColor, <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> arrowColor
        );
        <SPAN CLASS=t>static void </SPAN>PaintHighlightArrowsOnBow(
                <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPainter_h.html#emPainter">emPainter</A> &amp; painter, <SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y, <SPAN CLASS=t>double </SPAN>radius,
                <SPAN CLASS=t>int </SPAN>quadrant, <SPAN CLASS=t>double </SPAN>pos, <SPAN CLASS=t>double </SPAN>delta, <SPAN CLASS=t>int </SPAN>count,
                <SPAN CLASS=t>double </SPAN>goalX, <SPAN CLASS=t>double </SPAN>goalY, <SPAN CLASS=t>double </SPAN>arrowSize,
                <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> shadowColor, <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> arrowColor
        );
        <SPAN CLASS=t>static void </SPAN>PaintHighlightArrow(
                <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPainter_h.html#emPainter">emPainter</A> &amp; painter, <SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y,
                <SPAN CLASS=t>double </SPAN>goalX, <SPAN CLASS=t>double </SPAN>goalY, <SPAN CLASS=t>double </SPAN>arrowSize,
                <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> shadowColor, <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> arrowColor
        );

        <SPAN CLASS=t>void </SPAN>SetSeekPos(<A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * panel, <SPAN CLASS=t>const char </SPAN>* childName);
        <SPAN CLASS=t>bool </SPAN>IsHopeForSeeking() <SPAN CLASS=t>const</SPAN>;

        <SPAN CLASS=t>class </SPAN>UpdateEngineClass : <SPAN CLASS=t>public </SPAN><A CLASS=l HREF="emCore_emEngine_h.html#emEngine">emEngine</A> <SPAN CLASS=b>{
        </SPAN><SPAN CLASS=t>public</SPAN>:
                UpdateEngineClass(<A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> &amp; view);
        <SPAN CLASS=t>protected</SPAN>:
                <SPAN CLASS=t>virtual bool </SPAN>Cycle();
        <SPAN CLASS=t>private</SPAN>:
                <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> &amp; View;
        <SPAN CLASS=b>}</SPAN>;
        <SPAN CLASS=t>friend class </SPAN>UpdateEngineClass;

        <SPAN CLASS=t>class </SPAN>EOIEngineClass : <SPAN CLASS=t>public </SPAN><A CLASS=l HREF="emCore_emEngine_h.html#emEngine">emEngine</A> <SPAN CLASS=b>{
        </SPAN><SPAN CLASS=t>public</SPAN>:
                EOIEngineClass(<A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> &amp; view);
        <SPAN CLASS=t>protected</SPAN>:
                <SPAN CLASS=t>virtual bool </SPAN>Cycle();
        <SPAN CLASS=t>private</SPAN>:
                <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> &amp; View;
                <SPAN CLASS=t>int </SPAN>CountDown;
        <SPAN CLASS=b>}</SPAN>;
        <SPAN CLASS=t>friend class </SPAN>EOIEngineClass;

        <SPAN CLASS=t>class </SPAN>StressTestClass : <SPAN CLASS=t>public </SPAN><A CLASS=l HREF="emCore_emEngine_h.html#emEngine">emEngine</A> <SPAN CLASS=b>{
        </SPAN><SPAN CLASS=t>public</SPAN>:
                StressTestClass(<A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> &amp; view);
                <SPAN CLASS=t>virtual </SPAN>~StressTestClass();
                <SPAN CLASS=t>void </SPAN>PaintInfo(<SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPainter_h.html#emPainter">emPainter</A> &amp; painter) <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>protected</SPAN>:
                <SPAN CLASS=t>virtual bool </SPAN>Cycle();
        <SPAN CLASS=t>private</SPAN>:
                <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> &amp; View;
                <SPAN CLASS=t>int </SPAN>TCnt,TPos,TValid;
                emUInt64 * T;
                <SPAN CLASS=t>double </SPAN>FrameRate;
                emUInt64 FRUpdate;
        <SPAN CLASS=b>}</SPAN>;
        <SPAN CLASS=t>friend class </SPAN>StressTestClass;

        <A CLASS=l HREF="emCore_emCrossPtr_h.html#emCrossPtrList">emCrossPtrList</A> CrossPtrList;
        <A CLASS=l HREF="emCore_emRef_h.html#emRef">emRef</A>&lt;<A CLASS=l HREF="emCore_emCoreConfig_h.html#emCoreConfig">emCoreConfig</A>&gt; CoreConfig;
        <A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A> * DummyViewPort;
        <A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A> * HomeViewPort;
        <A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A> * CurrentViewPort;
        <A CLASS=l HREF="emCore_emWindow_h.html#emWindow">emWindow</A> * Window;
        <A CLASS=l HREF="emCore_emRef_h.html#emRef">emRef</A>&lt;<A CLASS=l HREF="emCore_emModel_h.html#emModel">emModel</A>&gt; ScreenRef;
        <A CLASS=l HREF="emCore_emWindow_h.html#emWindow">emWindow</A> * PopupWindow;
        <A CLASS=l HREF="emCore_emViewInputFilter_h.html#emViewInputFilter">emViewInputFilter</A> * FirstVIF;
        <A CLASS=l HREF="emCore_emViewInputFilter_h.html#emViewInputFilter">emViewInputFilter</A> * LastVIF;
        <A CLASS=l HREF="emCore_emViewAnimator_h.html#emViewAnimator">emViewAnimator</A> * ActiveAnimator;
        <A CLASS=l HREF="emCore_emViewAnimator_h.html#emMagneticViewAnimator">emMagneticViewAnimator</A> * MagneticVA;
        <A CLASS=l HREF="emCore_emViewAnimator_h.html#emVisitingViewAnimator">emVisitingViewAnimator</A> * VisitingVA;
        <A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * RootPanel;
        <A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * SupremeViewedPanel;
        <A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * MinSVP, * MaxSVP;
        <A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * ActivePanel;
        <A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> ViewFlagsSignal;
        <A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> TitleSignal;
        <A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> ControlPanelSignal;
        <A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> FocusSignal;
        <A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> GeometrySignal;
        <A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> EOISignal;
        <SPAN CLASS=t>double </SPAN>HomeX,HomeY,HomeWidth,HomeHeight,HomePixelTallness;
        <SPAN CLASS=t>double </SPAN>CurrentX,CurrentY,CurrentWidth,CurrentHeight,
               CurrentPixelTallness;
        <SPAN CLASS=t>double </SPAN>LastMouseX,LastMouseY;
        <A CLASS=l HREF="emCore_emString_h.html#emString">emString</A> Title;
        <A CLASS=l HREF="emCore_emCursor_h.html#emCursor">emCursor</A> Cursor;
        <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> BackgroundColor;
        ViewFlags VFlags;
        <SPAN CLASS=t>bool </SPAN>Focused;
        <SPAN CLASS=t>bool </SPAN>ActivationAdherent;
        <SPAN CLASS=t>bool </SPAN>ZoomScrollInAction;
        <SPAN CLASS=t>bool </SPAN>TitleInvalid;
        <SPAN CLASS=t>bool </SPAN>CursorInvalid;
        <SPAN CLASS=t>bool </SPAN>SVPChoiceInvalid;
        <SPAN CLASS=t>bool </SPAN>SVPChoiceByOpacityInvalid;
        <SPAN CLASS=t>bool </SPAN>RestartInputRecursion;
        <SPAN CLASS=t>bool </SPAN>ZoomedOutBeforeSG;
        <SPAN CLASS=t>int </SPAN>SettingGeometry;
        <SPAN CLASS=t>int </SPAN>SVPUpdCount;
        emUInt64 SVPUpdSlice;
        <A CLASS=l HREF="emCore_emInput_h.html#emInputEvent">emInputEvent</A> NoEvent;
        PanelRingNode NoticeList;
        UpdateEngineClass * UpdateEngine;
        EOIEngineClass * EOIEngine;
        <A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * SeekPosPanel;
        <A CLASS=l HREF="emCore_emString_h.html#emString">emString</A> SeekPosChildName;
        StressTestClass * StressTest;

        <SPAN CLASS=t>static const double </SPAN>MaxSVPSize;
        <SPAN CLASS=t>static const double </SPAN>MaxSVPSearchSize;
<SPAN CLASS=b>}</SPAN>;


<A NAME="emViewPort"></A><SPAN CLASS=c>//==============================================================================
//================================= <A CLASS=m HREF="emCore_emView_h.html#emViewPort">emViewPort</A> =================================
//==============================================================================

</SPAN><SPAN CLASS=t>class </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A> : <SPAN CLASS=t>public </SPAN><A CLASS=l HREF="emCore_emStd1_h.html#emUncopyable">emUncopyable</A> <SPAN CLASS=b>{

</SPAN><SPAN CLASS=t>public</SPAN>:

        <SPAN CLASS=c>// Base class for the connection between an <A CLASS=m HREF="emCore_emView_h.html#emView">emView</A> and the operating
        // system or the hardware or whatever. The default implementation
        // connects the view to nothing. When a view is constructed, it creates
        // such a dummy view port just to have a view port at all. A real view
        // port should be created on the view afterwards. For example, this is
        // solved in <A CLASS=m HREF="emCore_emWindow_h.html#emWindow">emWindow</A> by creating an <A CLASS=m HREF="emCore_emWindow_h.html#emWindowPort">emWindowPort</A>, which is a derivative
        // of <A CLASS=m HREF="emCore_emView_h.html#emViewPort">emViewPort</A>.
        //
        // Note that <A CLASS=m HREF="emCore_emView_h.html#emView">emView</A> implements some tricks for solving the popup-zoom
        // feature. When popping up, the view creates a private <A CLASS=m HREF="emCore_emWindow_h.html#emWindow">emWindow</A> and
        // exchanges the view port of that window for its own view port
        // temporarily. A view port derivative must come clear with such an
        // exchange (do not store any references to the view in it).
        //
        // The title is not interfaced through <A CLASS=m HREF="emCore_emView_h.html#emViewPort">emViewPort</A> (but through
        // <A CLASS=m HREF="emCore_emWindow_h.html#emWindowPort">emWindowPort</A>) because it must not be exchanged when the view pops up.
        //
        // The popup-zoom feature is even the reason why all views must share
        // the same coordinate system. It should be the coordinate system of
        // screen.

        </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>(<A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> &amp; homeView);

        <SPAN CLASS=t>virtual </SPAN>~<A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>();

        <SPAN CLASS=t>double </SPAN>GetViewX() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetViewY() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetViewWidth() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>double </SPAN>GetViewHeight() <SPAN CLASS=t>const</SPAN>;

        <A CLASS=l HREF="emCore_emCursor_h.html#emCursor">emCursor</A> GetViewCursor() <SPAN CLASS=t>const</SPAN>;

        <SPAN CLASS=t>void </SPAN>PaintView(<SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPainter_h.html#emPainter">emPainter</A> &amp; painter, <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> canvasColor) <SPAN CLASS=t>const</SPAN>;

<SPAN CLASS=t>protected</SPAN>:

        <SPAN CLASS=t>void </SPAN>SetViewGeometry(<SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y, <SPAN CLASS=t>double </SPAN>w, <SPAN CLASS=t>double </SPAN>h,
                             <SPAN CLASS=t>double </SPAN>pixelTallness);

        <SPAN CLASS=t>void </SPAN>SetViewFocused(<SPAN CLASS=t>bool </SPAN>focused);
        <SPAN CLASS=t>virtual void </SPAN>RequestFocus();

        <SPAN CLASS=t>virtual bool </SPAN>IsSoftKeyboardShown() <SPAN CLASS=t>const</SPAN>;
        <SPAN CLASS=t>virtual void </SPAN>ShowSoftKeyboard(<SPAN CLASS=t>bool </SPAN>show);

        <SPAN CLASS=t>virtual </SPAN>emUInt64 GetInputClockMS() <SPAN CLASS=t>const</SPAN>;

        <SPAN CLASS=t>void </SPAN>InputToView(<A CLASS=l HREF="emCore_emInput_h.html#emInputEvent">emInputEvent</A> &amp; event, <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emInput_h.html#emInputState">emInputState</A> &amp; state);

        <SPAN CLASS=t>virtual void </SPAN>InvalidateCursor();

        <SPAN CLASS=t>virtual void </SPAN>InvalidatePainting(<SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y, <SPAN CLASS=t>double </SPAN>w, <SPAN CLASS=t>double </SPAN>h);

        <SPAN CLASS=c>// - - - - - - - - - - Depreciated methods - - - - - - - - - - - - - - -
        // The following virtual non-const methods have been replaced by const
        // methods (see above). The old versions still exist here with the
        // "final" keyword added, so that old overridings will fail to compile.
        // If you run into this, please adapt your overridings by adding "const".
        </SPAN><SPAN CLASS=t>virtual bool </SPAN>IsSoftKeyboardShown() final;
        <SPAN CLASS=t>virtual </SPAN>emUInt64 GetInputClockMS() final;
        <SPAN CLASS=c>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

</SPAN><SPAN CLASS=t>private</SPAN>:
        <SPAN CLASS=t>friend class </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>;
        <A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>();
        <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> * HomeView;
        <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A> * CurrentView;
<SPAN CLASS=b>}</SPAN>;


<SPAN CLASS=c>//==============================================================================
//============================== Implementations ===============================
//==============================================================================

//----------------------------------- <A CLASS=m HREF="emCore_emView_h.html#emView">emView</A> -----------------------------------

</SPAN><SPAN CLASS=t>inline void </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::LinkCrossPtr(emCrossPtrPrivate &amp; crossPtr)
<SPAN CLASS=b>{
        </SPAN>CrossPtrList.LinkCrossPtr(crossPtr);
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::ViewFlags <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetViewFlags() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>VFlags;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetViewFlagsSignal() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>ViewFlagsSignal;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetBackgroundColor() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>BackgroundColor;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetTitleSignal() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>TitleSignal;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetControlPanelSignal() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>ControlPanelSignal;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline bool </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::IsFocused() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>Focused;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetFocusSignal() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>FocusSignal;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emWindow_h.html#emWindow">emWindow</A> * <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetWindow() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>Window;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetHomeX() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>HomeX;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetHomeY() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>HomeY;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetHomeWidth() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>HomeWidth;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetHomeHeight() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>HomeHeight;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetHomePixelTallness() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>HomePixelTallness;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetHomeTallness() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>HomeHeight/HomeWidth*HomePixelTallness;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetCurrentX() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentX;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetCurrentY() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentY;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetCurrentWidth() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentWidth;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetCurrentHeight() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentHeight;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetCurrentPixelTallness() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentPixelTallness;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetCurrentTallness() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentHeight/CurrentWidth*CurrentPixelTallness;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetGeometrySignal() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>GeometrySignal;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emViewInputFilter_h.html#emViewInputFilter">emViewInputFilter</A> * <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetFirstVIF() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>FirstVIF;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emViewInputFilter_h.html#emViewInputFilter">emViewInputFilter</A> * <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetLastVIF() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>LastVIF;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetRootPanel() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>RootPanel;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetSupremeViewedPanel() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>SupremeViewedPanel;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emPanel_h.html#emPanel">emPanel</A> * <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetActivePanel() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>ActivePanel;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline bool </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::IsActivationAdherent() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>ActivationAdherent;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline bool </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::IsPoppedUp() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>PopupWindow!=<SPAN CLASS=u>NULL</SPAN>;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline const </SPAN><A CLASS=l HREF="emCore_emSignal_h.html#emSignal">emSignal</A> &amp; <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetEOISignal() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>EOISignal;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline bool </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::IsSoftKeyboardShown() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentViewPort-&gt;IsSoftKeyboardShown();
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline void </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::ShowSoftKeyboard(<SPAN CLASS=t>bool </SPAN>show)
<SPAN CLASS=b>{
        </SPAN>CurrentViewPort-&gt;ShowSoftKeyboard(show);
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN>emUInt64 <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetInputClockMS() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentViewPort-&gt;GetInputClockMS();
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emViewAnimator_h.html#emViewAnimator">emViewAnimator</A> * <A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::GetActiveAnimator() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>ActiveAnimator;
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline void </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::InvalidateCursor()
<SPAN CLASS=b>{
        </SPAN>CurrentViewPort-&gt;InvalidateCursor();
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline void </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::InvalidatePainting()
<SPAN CLASS=b>{
        </SPAN>CurrentViewPort-&gt;InvalidatePainting(
                CurrentX,CurrentY,CurrentWidth,CurrentHeight
        );
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline void </SPAN><A CLASS=l HREF="emCore_emView_h.html#emView">emView</A>::InvalidatePainting(<SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y, <SPAN CLASS=t>double </SPAN>w, <SPAN CLASS=t>double </SPAN>h)
<SPAN CLASS=b>{
        </SPAN>CurrentViewPort-&gt;InvalidatePainting(x,y,w,h);
<SPAN CLASS=b>}


</SPAN><SPAN CLASS=c>//--------------------------------- <A CLASS=m HREF="emCore_emView_h.html#emViewPort">emViewPort</A> ---------------------------------

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>::GetViewX() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentView-&gt;GetCurrentX();
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>::GetViewY() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentView-&gt;GetCurrentY();
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>::GetViewWidth() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentView-&gt;GetCurrentWidth();
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline double </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>::GetViewHeight() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentView-&gt;GetCurrentHeight();
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline </SPAN><A CLASS=l HREF="emCore_emCursor_h.html#emCursor">emCursor</A> <A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>::GetViewCursor() <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN><SPAN CLASS=k>return </SPAN>CurrentView-&gt;GetCursor();
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline void </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>::PaintView(
        <SPAN CLASS=t>const </SPAN><A CLASS=l HREF="emCore_emPainter_h.html#emPainter">emPainter</A> &amp; painter, <A CLASS=l HREF="emCore_emColor_h.html#emColor">emColor</A> canvasColor
) <SPAN CLASS=t>const
</SPAN><SPAN CLASS=b>{
        </SPAN>CurrentView-&gt;Paint(painter,canvasColor);
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline void </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>::SetViewGeometry(
        <SPAN CLASS=t>double </SPAN>x, <SPAN CLASS=t>double </SPAN>y, <SPAN CLASS=t>double </SPAN>w, <SPAN CLASS=t>double </SPAN>h, <SPAN CLASS=t>double </SPAN>pixelTallness
)
<SPAN CLASS=b>{
        </SPAN>CurrentView-&gt;SetGeometry(x,y,w,h,pixelTallness);
<SPAN CLASS=b>}

</SPAN><SPAN CLASS=t>inline void </SPAN><A CLASS=l HREF="emCore_emView_h.html#emViewPort">emViewPort</A>::SetViewFocused(<SPAN CLASS=t>bool </SPAN>focused)
<SPAN CLASS=b>{
        </SPAN>CurrentView-&gt;SetFocused(focused);
<SPAN CLASS=b>}


</SPAN><SPAN CLASS=p>#endif
</SPAN></SPAN></TT></PRE>
</BODY>
</HTML>
